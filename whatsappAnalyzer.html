<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhatsApp Chat Analyzer</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
        }
        #dropZone {
            border: 3px dashed #ccc;
            padding: 50px;
            text-align: center;
            background-color: #fff;
            margin-bottom: 20px;
            cursor: pointer;
        }
        #dropZone.hover {
            border-color: #333;
            background-color: #eee;
        }
        #fileName {
            margin-top: 10px;
            font-style: italic;
            color: #555;
        }
        #controls {
            margin-bottom: 20px;
        }
        #results {
            background-color: #fff;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #e9e9e9;
        }
        #loading {
            display: none;
            text-align: center;
            font-weight: bold;
            color: #007bff;
            margin-top: 10px;
        }
         /* Simple responsive adjustments */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            #dropZone {
                padding: 30px;
            }
            th, td {
                padding: 5px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>

    <h1>WhatsApp Chat Analyzer</h1>

    <div id="dropZone">
        Drag & Drop your WhatsApp Chat .txt file here
        <div id="fileName"></div>
        <input type="file" id="fileInput" accept=".txt" style="display: none;">
    </div>

    <div id="controls">
        <label for="timeframe">Select Timeframe:</label>
        <select id="timeframe" disabled>
            <option value="lifetime">Lifetime</option>
            <option value="last_1_month">Last 1 Month</option>
            <option value="last_3_months">Last 3 Months</option>
            <option value="last_6_months">Last 6 Months</option>
            <option value="last_12_months">Last 12 Months</option>
            </select>
    </div>

    <div id="loading">Processing... Please wait for large files.</div>
    <div id="results">
        Please drop a file to see the analysis.
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const timeframeSelect = document.getElementById('timeframe');
        const resultsDiv = document.getElementById('results');
        const loadingDiv = document.getElementById('loading');

        let allMessages = []; // Store all parsed messages {date, sender, text}
        let availableMonths = new Set(); // To store YYYY-MM

        // --- Drag & Drop ---
        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropZone.classList.add('hover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('hover');
        });

        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropZone.classList.remove('hover');
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        // Allow clicking the drop zone to select file
         dropZone.addEventListener('click', () => {
            fileInput.click();
        });

         fileInput.addEventListener('change', (event) => {
             const files = event.target.files;
             if (files.length > 0) {
                 handleFile(files[0]);
             }
         });

        // --- File Handling & Parsing ---
        function handleFile(file) {
            if (file.type === 'text/plain') {
                fileNameDisplay.textContent = `Selected: ${file.name}`;
                resultsDiv.innerHTML = ''; // Clear previous results
                loadingDiv.style.display = 'block'; // Show loading indicator
                 // Reset
                allMessages = [];
                availableMonths = new Set();
                resetTimeframeSelect();

                const reader = new FileReader();
                reader.onload = (e) => {
                     // Use setTimeout to allow UI update before heavy processing
                    setTimeout(() => {
                        parseChat(e.target.result);
                        enableControlsAndAnalyze();
                        loadingDiv.style.display = 'none'; // Hide loading
                    }, 10); // Small delay
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    resultsDiv.textContent = 'Error reading file.';
                    loadingDiv.style.display = 'none';
                };
                reader.readAsText(file);
            } else {
                fileNameDisplay.textContent = '';
                resultsDiv.textContent = 'Please drop a valid .txt file.';
            }
        }

        function resetTimeframeSelect() {
            // Remove old month options
            const options = timeframeSelect.querySelectorAll('option');
            options.forEach(option => {
                if (option.value.startsWith('month_')) {
                    option.remove();
                }
            });
            timeframeSelect.value = 'lifetime'; // Reset selection
        }

        function parseChat(chatContent) {
            // Regex for iOS format: [DD/MM/YYYY, HH:MM:SS] Sender: Message
            // Group 1: Date (DD/MM/YYYY)
            // Group 2: Time (HH:MM:SS)
            // Group 3: Sender
            // Group 4: Message
            const iosRegex = /^\[(\d{1,2}\/\d{1,2}\/\d{4}), (\d{1,2}:\d{2}:\d{2})\]\s*([^:]+):\s*(.*)/;

            // Regex for other common format (e.g., Android): M/D/YY, HH:MM AM/PM - Sender: Message
            // Group 1: Date (M/D/YY or similar)
            // Group 2: Time (HH:MM AM/PM or HH:MM)
            // Group 3: Sender
            // Group 4: Message
            const androidRegex = /^(\d{1,2}\/\d{1,2}\/\d{2,4}), (\d{1,2}:\d{2}(?:\s?[AP]M)?)\s*-\s*([^:]+):\s*(.*)/;

            const lines = chatContent.split('\n');
            allMessages = []; // Reset messages
            availableMonths = new Set(); // Reset months

            lines.forEach(line => {
                let match = line.match(iosRegex);
                let dateStr, sender, text;
                let matched = false;

                if (match) {
                    dateStr = match[1].trim(); // DD/MM/YYYY
                    sender = match[3].trim();
                    text = match[4].trim();
                    matched = true;
                } else {
                    match = line.match(androidRegex);
                    if (match) {
                        dateStr = match[1].trim(); // M/D/YY or similar
                        sender = match[3].trim();
                        text = match[4].trim();
                        matched = true;
                    }
                }

                if (matched) {
                    // Attempt to parse the date using the extracted date string
                    let date = parseDate(dateStr);

                    if (date) {
                         // Basic filter for common system messages often attributed to users in iOS exports
                         // NOTE: This is language-specific (Portuguese example shown) and might not be exhaustive
                         if (!text.startsWith('‎As mensagens e ligações') && !text.startsWith('‎entrou usando um link') && !text.includes('‎saiu')) {
                             allMessages.push({ date, sender, text });

                             // Store available months for dropdown
                             const year = date.getFullYear();
                             const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Month is 0-indexed
                             availableMonths.add(`${year}-${month}`);
                         }
                    } else {
                        console.warn("Could not parse date:", dateStr, "in line:", line);
                    }
                }
                // Ignore lines that don't match either format
            });
             console.log(`Parsed ${allMessages.length} valid user messages.`);
        }

        function parseDate(dateStr) {
             // Try DD/MM/YYYY format (common in iOS exports and non-US Android)
             let parts = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
             if (parts) {
                 let day = parseInt(parts[1], 10);
                 let month = parseInt(parts[2], 10) - 1; // JS months are 0-indexed
                 let year = parseInt(parts[3], 10);
                  // Basic sanity check for DD/MM order
                 if (month >= 0 && month < 12 && day > 0 && day <= 31) {
                    const date = new Date(year, month, day);
                    // Check if the constructed date is valid (accounts for days in month)
                    if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
                        return date;
                    }
                 }
             }

            // Try M/D/YY format (common in US Android exports)
             parts = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
             if (parts) {
                 let month = parseInt(parts[1], 10) - 1; // JS months are 0-indexed
                 let day = parseInt(parts[2], 10);
                 let year = parseInt(parts[3], 10) + 2000; // Assuming 21st century
                  // Basic sanity check for MM/DD order
                 if (month >= 0 && month < 12 && day > 0 && day <= 31) {
                    const date = new Date(year, month, day);
                     // Check if the constructed date is valid
                    if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
                        return date;
                    }
                 }
             }

            // Try M/D/YYYY format (less common but possible)
            parts = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
            if (parts) {
                 let month = parseInt(parts[1], 10) - 1; // JS months are 0-indexed
                 let day = parseInt(parts[2], 10);
                 let year = parseInt(parts[3], 10);
                  // Basic sanity check for MM/DD order
                 if (month >= 0 && month < 12 && day > 0 && day <= 31) {
                    const date = new Date(year, month, day);
                    // Check if the constructed date is valid
                    if (date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
                        return date;
                    }
                 }
            }


             // Add more parsing attempts here if needed for other formats
             // console.error("Failed to parse date format:", dateStr); // Reduce console noise
             return null; // Indicate failure
         }


        function enableControlsAndAnalyze() {
            if (allMessages.length > 0) {
                 populateMonthOptions();
                 timeframeSelect.disabled = false;
                  // Ensure event listener isn't added multiple times
                 timeframeSelect.removeEventListener('change', analyzeChat);
                 timeframeSelect.addEventListener('change', analyzeChat);
                 analyzeChat(); // Perform initial analysis for "Lifetime"
             } else {
                 resultsDiv.textContent = 'No valid user messages found or parsed in the file. Check file format/content?';
                 timeframeSelect.disabled = true;
             }
        }

        function populateMonthOptions() {
            const sortedMonths = Array.from(availableMonths).sort().reverse(); // Newest first
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

             sortedMonths.forEach(monthYear => { // format YYYY-MM
                 const [year, month] = monthYear.split('-');
                 const option = document.createElement('option');
                 option.value = `month_${monthYear}`;
                 option.textContent = `${monthNames[parseInt(month, 10) - 1]} ${year}`;
                 timeframeSelect.appendChild(option);
             });
        }


        // --- Analysis & Display ---
        function analyzeChat() {
            const selectedTimeframe = timeframeSelect.value;
            const now = new Date();
            let startDate = null;
            let endDate = null;

             // Set time to 00:00:00 for start dates and 23:59:59 for end dates for accurate comparison
             now.setHours(23, 59, 59, 999);

            if (selectedTimeframe.startsWith('month_')) {
                 const [year, month] = selectedTimeframe.substring(6).split('-').map(Number);
                 startDate = new Date(year, month - 1, 1); // Month is 0-indexed, start of day
                 startDate.setHours(0, 0, 0, 0);
                 endDate = new Date(year, month, 0); // Last day of the month
                 endDate.setHours(23, 59, 59, 999); // End of day
            } else {
                 endDate = new Date(); // Use current date/time as end for relative periods
                 endDate.setHours(23, 59, 59, 999);

                 switch (selectedTimeframe) {
                    case 'last_1_month':
                        startDate = new Date();
                        startDate.setMonth(startDate.getMonth() - 1);
                        break;
                    case 'last_3_months':
                         startDate = new Date();
                         startDate.setMonth(startDate.getMonth() - 3);
                        break;
                    case 'last_6_months':
                         startDate = new Date();
                          startDate.setMonth(startDate.getMonth() - 6);
                         break;
                     case 'last_12_months':
                          startDate = new Date();
                          startDate.setFullYear(startDate.getFullYear() - 1);
                         break;
                     case 'lifetime':
                     default:
                         startDate = null; // No start date means include all
                         break;
                 }
                 if(startDate) {
                    startDate.setHours(0, 0, 0, 0); // Start of the day
                 }
            }


            const messageCounts = {};
            let filteredMessageCount = 0;

            allMessages.forEach(msg => {
                 // Check if message date falls within the selected range
                 let includeMessage = false;
                 if (!startDate) { // Lifetime
                     includeMessage = true;
                 } else if (msg.date >= startDate && msg.date <= endDate) { // Check if date is within bounds
                     includeMessage = true;
                 }


                 if (includeMessage) {
                     messageCounts[msg.sender] = (messageCounts[msg.sender] || 0) + 1;
                     filteredMessageCount++;
                 }
             });

            // Convert to array and sort
            const sortedMembers = Object.entries(messageCounts)
                .sort(([, countA], [, countB]) => countB - countA); // Sort descending by count

            displayResults(sortedMembers, filteredMessageCount, selectedTimeframe);
        }

        function displayResults(sortedMembers, totalMessagesInPeriod, timeframe) {
            if (sortedMembers.length === 0) {
                 resultsDiv.innerHTML = `<h3>No messages found for the selected timeframe: ${timeframeSelect.options[timeframeSelect.selectedIndex].text}</h3>`;
                 return;
             }

            let tableHTML = `
                <h3>Activity Ranking (${timeframeSelect.options[timeframeSelect.selectedIndex].text})</h3>
                <p>Total messages found in this period: ${totalMessagesInPeriod}</p>
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Member</th>
                            <th>Message Count</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            sortedMembers.forEach(([sender, count], index) => {
                tableHTML += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${escapeHTML(sender)}</td>
                        <td>${count}</td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                </table>
            `;

            resultsDiv.innerHTML = tableHTML;
        }

         // Simple HTML escaping function
         function escapeHTML(str) {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        }

    </script>

</body>
</html>